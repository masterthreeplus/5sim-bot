import telebot
import requests
import time
import threading
import os
import certifi
import logging
from flask import Flask
from telebot import types
from pymongo import MongoClient
from datetime import datetime

# ---------------- LOGGING SETUP ----------------
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# ---------------- SECURITY CHECK & CONFIG ----------------
# Environment Variables ·Äô·Äõ·Äæ·Ä≠·Äõ·ÄÑ·Ä∫ Error ·Äê·ÄÄ·Ä∫·Äï·Äº·ÄÆ·Ä∏ ·Äõ·Äï·Ä∫·Äû·ÄΩ·Ä¨·Ä∏·Äï·Ä´·Äô·Äö·Ä∫ (Security)
def get_env_var(name):
    val = os.environ.get(name)
    if not val:
        logger.critical(f"‚ùå Missing Environment Variable: {name}")
        raise ValueError(f"Missing {name}")
    return val

BOT_TOKEN = get_env_var('BOT_TOKEN')
API_KEY = get_env_var('SIM_API_KEY')
MONGO_URI = get_env_var('MONGO_URI')
# Optional vars
ADMIN_ID = int(os.environ.get('ADMIN_ID', '0')) # 0 if not set
PORT = int(os.environ.get('PORT', 8080))

# Economics
RUB_TO_MMK = 57.38
PROFIT_PERCENT = 25

# 5sim API
BASE_URL = "https://5sim.net/v1"
HEADERS = {'Authorization': 'Bearer ' + API_KEY, 'Accept': 'application/json'}

# ---------------- THREAD LOCK & CACHE ----------------
db_lock = threading.Lock() # Database race condition ·ÄÄ·Ä¨·ÄÄ·ÄΩ·Äö·Ä∫·Äõ·Äî·Ä∫
price_cache = {} # API Rate Limit ·ÄÄ·Ä¨·ÄÄ·ÄΩ·Äö·Ä∫·Äõ·Äî·Ä∫ Cache
CACHE_DURATION = 600 # 10 Minutes cache

# ---------------- DATABASE SETUP ----------------
try:
    client = MongoClient(MONGO_URI, tlsCAFile=certifi.where())
    db = client['5sim_reseller_db']
    users_collection = db['users']
    orders_collection = db['orders']
    logger.info("‚úÖ Connected to MongoDB")
except Exception as e:
    logger.critical(f"‚ùå Database Connection Failed: {e}")
    raise e

# ---------------- DATABASE FUNCTIONS (SAFE MODE) ----------------

def get_user(user_id):
    return users_collection.find_one({'_id': user_id})

def register_user(user_id, first_name):
    if not get_user(user_id):
        users_collection.insert_one({
            '_id': user_id,
            'name': first_name,
            'balance': 0,
            'joined_at': time.time()
        })

def update_balance(user_id, amount):
    # Thread Lock ·Äû·ÄØ·Ä∂·Ä∏·Äï·Äº·ÄÆ·Ä∏ ·Äï·Ä≠·ÄØ·ÄÄ·Ä∫·ÄÜ·Ä∂·Ä°·Äî·ÄØ·Äê·Ä∫·Äô·Äï·Äº·Ä°·Ä±·Ä¨·ÄÑ·Ä∫ ·ÄÄ·Ä¨·ÄÄ·ÄΩ·Äö·Ä∫·ÄÅ·Äº·ÄÑ·Ä∫·Ä∏
    with db_lock:
        user = get_user(user_id)
        if not user: return False
        
        new_balance = user.get('balance', 0) + amount
        if new_balance < 0:
            return False # Not enough money (Double Check)
            
        users_collection.update_one({'_id': user_id}, {'$inc': {'balance': amount}})
        return True

def get_all_users_list():
    return list(users_collection.find())

# --- ORDER HISTORY ---
def save_order(user_id, order_id, phone, country, service, cost, status="PENDING"):
    orders_collection.insert_one({
        '_id': order_id,
        'user_id': user_id,
        'phone': phone,
        'country': country,
        'service': service,
        'cost': cost,
        'status': status,
        'sms': None,
        'timestamp': datetime.now()
    })

def update_order_status(order_id, status, sms_text=None):
    update_data = {'status': status}
    if sms_text:
        update_data['sms'] = sms_text
    orders_collection.update_one({'_id': order_id}, {'$set': update_data})

def get_user_history(user_id, limit=5):
    return list(orders_collection.find({'user_id': user_id}).sort('timestamp', -1).limit(limit))

# ---------------- PRICE CACHING SYSTEM ----------------
def get_cached_prices(product):
    current_time = time.time()
    
    # Check if data exists and is fresh (less than 10 mins old)
    if product in price_cache:
        cached_data = price_cache[product]
        if current_time - cached_data['timestamp'] < CACHE_DURATION:
            return cached_data['data']
    
    # If not in cache or expired, fetch from API
    try:
        resp = requests.get(f"{BASE_URL}/guest/prices?product={product}", headers=HEADERS)
        if resp.status_code == 200:
            data = resp.json()
            # Save to cache
            price_cache[product] = {
                'timestamp': current_time,
                'data': data
            }
            return data
    except Exception as e:
        logger.error(f"API Error: {e}")
    
    return {} # Return empty if fail

# ---------------- FLASK SERVER ----------------
app = Flask(__name__)
@app.route('/')
def home(): return "Bot is Running Securely!"
def run_web(): app.run(host='0.0.0.0', port=PORT)
def keep_alive(): threading.Thread(target=run_web, daemon=True).start()

bot = telebot.TeleBot(BOT_TOKEN)

# Popular Services
POPULAR_SERVICES = [
    'telegram', 'whatsapp', 'facebook', 'google', 'tiktok', 'viber', 
    'steam', 'discord', 'amazon', 'openai', 'shopee', 'lazada', 'netflix'
]

# ---------------- FULL FLAG MAPPING (150+ Countries) ----------------
FLAG_MAP = {
    'afghanistan': 'üá¶üá´', 'albania': 'üá¶üá±', 'algeria': 'üá©üáø', 'angola': 'üá¶üá¥', 'argentina': 'üá¶üá∑',
    'armenia': 'üá¶üá≤', 'australia': 'üá¶üá∫', 'austria': 'üá¶üáπ', 'azerbaijan': 'üá¶üáø', 'bahrain': 'üáßüá≠',
    'bangladesh': 'üáßüá©', 'belarus': 'üáßüáæ', 'belgium': 'üáßüá™', 'benin': 'üáßüáØ', 'bolivia': 'üáßüá¥',
    'bosnia': 'üáßüá¶', 'brazil': 'üáßüá∑', 'bulgaria': 'üáßüá¨', 'burkinafaso': 'üáßüá´', 'burundi': 'üáßüáÆ',
    'cambodia': 'üá∞üá≠', 'cameroon': 'üá®üá≤', 'canada': 'üá®üá¶', 'chad': 'üáπüá©', 'chile': 'üá®üá±',
    'china': 'üá®üá≥', 'colombia': 'üá®üá¥', 'congo': 'üá®üá¨', 'croatia': 'üá≠üá∑', 'cyprus': 'üá®üáæ',
    'czech': 'üá®üáø', 'denmark': 'üá©üá∞', 'djibouti': 'üá©üáØ', 'dominican': 'üá©üá¥', 'ecuador': 'üá™üá®',
    'egypt': 'üá™üá¨', 'england': 'üá¨üáß', 'equatorialguinea': 'üá¨üá∂', 'estonia': 'üá™üá™', 'ethiopia': 'üá™üáπ',
    'finland': 'üá´üáÆ', 'france': 'üá´üá∑', 'gabon': 'üá¨üá¶', 'gambia': 'üá¨üá≤', 'georgia': 'üá¨üá™',
    'germany': 'üá©üá™', 'ghana': 'üá¨üá≠', 'greece': 'üá¨üá∑', 'guatemala': 'üá¨üáπ', 'guinea': 'üá¨üá≥',
    'guineabissau': 'üá¨üáº', 'guyana': 'üá¨üáæ', 'haiti': 'üá≠üáπ', 'honduras': 'üá≠üá≥', 'hongkong': 'üá≠üá∞',
    'hungary': 'üá≠üá∫', 'india': 'üáÆüá≥', 'indonesia': 'üáÆüá©', 'iran': 'üáÆüá∑', 'iraq': 'üáÆüá∂',
    'ireland': 'üáÆüá™', 'israel': 'üáÆüá±', 'italy': 'üáÆüáπ', 'ivorycoast': 'üá®üáÆ', 'jamaica': 'üáØüá≤',
    'japan': 'üáØüáµ', 'jordan': 'üáØüá¥', 'kazakhstan': 'üá∞üáø', 'kenya': 'üá∞üá™', 'kuwait': 'üá∞üáº',
    'kyrgyzstan': 'üá∞üá¨', 'laos': 'üá±üá¶', 'latvia': 'üá±üáª', 'lebanon': 'üá±üáß', 'lesotho': 'üá±üá∏',
    'liberia': 'üá±üá∑', 'libya': 'üá±üáæ', 'lithuania': 'üá±üáπ', 'luxembourg': 'üá±üá∫', 'macau': 'üá≤üá¥',
    'madagascar': 'üá≤üá¨', 'malawi': 'üá≤üáº', 'malaysia': 'üá≤üáæ', 'maldives': 'üá≤üáª', 'mali': 'üá≤üá±',
    'mauritania': 'üá≤üá∑', 'mauritius': 'üá≤üá∫', 'mexico': 'üá≤üáΩ', 'moldova': 'üá≤üá©', 'mongolia': 'üá≤üá≥',
    'montenegro': 'üá≤üá™', 'morocco': 'üá≤üá¶', 'mozambique': 'üá≤üáø', 'myanmar': 'üá≤üá≤', 'namibia': 'üá≥üá¶',
    'nepal': 'üá≥üáµ', 'netherlands': 'üá≥üá±', 'newzealand': 'üá≥üáø', 'nicaragua': 'üá≥üáÆ', 'niger': 'üá≥üá™',
    'nigeria': 'üá≥üá¨', 'northmacedonia': 'üá≤üá∞', 'norway': 'üá≥üá¥', 'oman': 'üá¥üá≤', 'pakistan': 'üáµüá∞',
    'palestine': 'üáµüá∏', 'panama': 'üáµüá¶', 'papuanewguinea': 'üáµüá¨', 'paraguay': 'üáµüáæ', 'peru': 'üáµüá™',
    'philippines': 'üáµüá≠', 'poland': 'üáµüá±', 'portugal': 'üáµüáπ', 'qatar': 'üá∂üá¶', 'romania': 'üá∑üá¥',
    'russia': 'üá∑üá∫', 'rwanda': 'üá∑üáº', 'saudiarabia': 'üá∏üá¶', 'senegal': 'üá∏üá≥', 'serbia': 'üá∑üá∏',
    'sierraleone': 'üá∏üá±', 'singapore': 'üá∏üá¨', 'slovakia': 'üá∏üá∞', 'slovenia': 'üá∏üáÆ', 'somalia': 'üá∏üá¥',
    'southafrica': 'üáøüá¶', 'spain': 'üá™üá∏', 'srilanka': 'üá±üá∞', 'sudan': 'üá∏üá©', 'suriname': 'üá∏üá∑',
    'swaziland': 'üá∏üáø', 'sweden': 'üá∏üá™', 'switzerland': 'üá®üá≠', 'syria': 'üá∏üáæ', 'taiwan': 'üáπüáº',
    'tajikistan': 'üáπüáØ', 'tanzania': 'üáπüáø', 'thailand': 'üáπüá≠', 'timorleste': 'üáπüá±', 'togo': 'üáπüá¨',
    'tunisia': 'üáπüá≥', 'turkey': 'üáπüá∑', 'turkmenistan': 'üáπüá≤', 'uganda': 'üá∫üá¨', 'ukraine': 'üá∫üá¶',
    'uae': 'üá¶üá™', 'uk': 'üá¨üáß', 'usa': 'üá∫üá∏', 'uruguay': 'üá∫üáæ', 'uzbekistan': 'üá∫üáø',
    'venezuela': 'üáªüá™', 'vietnam': 'üáªüá≥', 'yemen': 'üáæüá™', 'zambia': 'üáøüá≤', 'zimbabwe': 'üáøüáº'
}

def get_flag(country_name):
    clean_name = country_name.lower().replace(" ", "")
    return FLAG_MAP.get(clean_name, 'üè≥Ô∏è')

# ---------------- HELPER FUNCTIONS ----------------

def calculate_display_price(rub_price, user_id):
    rub_price = float(rub_price)
    base_mmk = rub_price * RUB_TO_MMK
    if user_id == ADMIN_ID:
        return int(base_mmk)
    else:
        marked_up = base_mmk * (1 + PROFIT_PERCENT / 100)
        return int(marked_up)

def get_server_balance():
    try:
        resp = requests.get(f"{BASE_URL}/user/profile", headers=HEADERS).json()
        return float(resp.get('balance', 0))
    except:
        return 0.0

# ---------------- ADMIN COMMANDS ----------------

@bot.message_handler(commands=['admin'])
def admin_panel(message):
    if message.from_user.id != ADMIN_ID: return
    
    all_users = get_all_users_list()
    total_holdings = sum(u.get('balance', 0) for u in all_users)
    
    msg = (
        "üëë **Admin Control Panel**\n\n"
        f"üë• Total Users: `{len(all_users)}`\n"
        f"üí∞ Total User Holdings: `{total_holdings} Ks`\n\n"
        "**Commands:**\n"
        "`/users` - Get User List\n"
        "`/add [ID] [Amount]` - Add Balance\n"
        "`/cut [ID] [Amount]` - Deduct Balance\n"
        "`/info [ID]` - Check User History"
    )
    
    markup = types.InlineKeyboardMarkup()
    markup.add(types.InlineKeyboardButton("üë• Get User List", callback_data="admin_get_users"))
    bot.reply_to(message, msg, reply_markup=markup, parse_mode="Markdown")

@bot.message_handler(commands=['users'])
def cmd_get_users(message):
    if message.from_user.id != ADMIN_ID: return
    send_user_list(message.chat.id)

def send_user_list(chat_id):
    users = get_all_users_list()
    if not users:
        bot.send_message(chat_id, "No users found.")
        return

    msg_chunk = "üìã **User List:**\n\n"
    for u in users:
        line = f"üÜî `{u['_id']}` | {u.get('name', 'Unknown')} | üí∞ `{u.get('balance', 0)} Ks`\n"
        if len(msg_chunk) + len(line) > 3500:
            bot.send_message(chat_id, msg_chunk, parse_mode="Markdown")
            msg_chunk = ""
        msg_chunk += line
    if msg_chunk: bot.send_message(chat_id, msg_chunk, parse_mode="Markdown")

@bot.message_handler(commands=['add'])
def add_money(message):
    if message.from_user.id != ADMIN_ID: return
    try:
        parts = message.text.split()
        if len(parts) != 3: raise ValueError
        user_id = int(parts[1])
        amount = int(parts[2])
        
        # Safe Balance Update
        if update_balance(user_id, amount):
            bot.reply_to(message, f"‚úÖ Added `{amount} Ks` to User `{user_id}`.", parse_mode="Markdown")
            try: bot.send_message(user_id, f"üí∞ Deposit Received: `{amount} Ks`", parse_mode="Markdown")
            except: pass
        else:
            bot.reply_to(message, "‚ùå User ID not found.")
    except: bot.reply_to(message, "Error. Use: `/add 123456 1000`")

@bot.message_handler(commands=['cut'])
def cut_money(message):
    if message.from_user.id != ADMIN_ID: return
    try:
        parts = message.text.split()
        if len(parts) != 3: raise ValueError
        user_id = int(parts[1])
        amount = int(parts[2])
        
        # Safe Balance Update (Negative)
        if update_balance(user_id, -amount):
            bot.reply_to(message, f"‚úÇÔ∏è Deducted `{amount} Ks` from User `{user_id}`.", parse_mode="Markdown")
            try: bot.send_message(user_id, f"üìâ Balance Deducted: `{amount} Ks`", parse_mode="Markdown")
            except: pass
        else:
            bot.reply_to(message, "‚ùå User ID not found or Insufficient Balance.")
    except: bot.reply_to(message, "Error. Use: `/cut 123456 1000`")

@bot.message_handler(commands=['info'])
def user_info(message):
    if message.from_user.id != ADMIN_ID: return
    try:
        parts = message.text.split()
        if len(parts) != 2: raise ValueError
        uid = int(parts[1])
        u = get_user(uid)
        
        if u:
            msg = f"üë§ **User Info**\nID: `{uid}`\nName: {u.get('name')}\nBalance: `{u.get('balance')} Ks`\n\n"
            history = get_user_history(uid, limit=5)
            if history:
                msg += "üìú **Last 5 Orders:**\n"
                for order in history:
                    status_icon = "‚è≥"
                    if order['status'] == 'COMPLETED': status_icon = "‚úÖ"
                    elif order['status'] == 'CANCELED': status_icon = "‚ùå"
                    elif order['status'] == 'TIMEOUT': status_icon = "‚ö†Ô∏è"
                    
                    flag = get_flag(order['country'])
                    sms_info = f"\nüì© SMS: `{order['sms']}`" if order.get('sms') else ""
                    
                    msg += (f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                            f"üÜî `{order['_id']}` | {status_icon} {order['status']}\n"
                            f"{flag} {order['country'].upper()} | {order['service'].upper()}\n"
                            f"üì± `{order['phone']}` | üí∞ {order['cost']} Ks"
                            f"{sms_info}\n")
            else:
                msg += "üìú **History:** No orders yet."
            bot.reply_to(message, msg, parse_mode="Markdown")
        else:
            bot.reply_to(message, "‚ùå User not found.")
    except: bot.reply_to(message, "Error. Use: `/info 123456`")

# ---------------- USER COMMANDS ----------------

@bot.message_handler(commands=['start'])
def start(message):
    register_user(message.from_user.id, message.from_user.first_name)
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True, row_width=2)
    markup.add('üõí Buy Number', 'üë§ My Profile', 'üí≥ Top-up')
    bot.send_message(message.chat.id, f"Welcome {message.from_user.first_name}! üåç\nSelect an option below:", reply_markup=markup)

@bot.message_handler(func=lambda msg: True)
def main_menu(message):
    user_id = message.from_user.id
    text = message.text
    
    if text == 'üë§ My Profile':
        register_user(user_id, message.from_user.first_name)
        user = get_user(user_id)
        bal = user.get('balance', 0)
        
        msg_text = f"üë§ **User Profile**\n\nüÜî ID: `{user_id}`\nüë§ Name: {user.get('name')}\nüí∞ **Wallet Balance: {bal} Ks**"
        
        if user_id == ADMIN_ID:
            server_bal_rub = get_server_balance()
            server_bal_mmk = int(server_bal_rub * RUB_TO_MMK)
            all_u = get_all_users_list()
            total_user_mmk = sum(u.get('balance', 0) for u in all_u)
            msg_text += (f"\n\n‚öôÔ∏è **Admin Dashboard:**\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                         f"üîå **Server Balance:**\n   üá∑üá∫ `{server_bal_rub} RUB`\n   üá≤üá≤ `~{server_bal_mmk} MMK`\n\n"
                         f"üë• Total User Funds: `{total_user_mmk} Ks`")
        bot.reply_to(message, msg_text, parse_mode="Markdown")
        
    elif text == 'üí≥ Top-up':
        msg = (f"üí∏ **To top-up your wallet, please contact Admin.**\n\nüë§ Admin: @Shake0098\nüÜî Your ID: `{user_id}`\n\n"
               f"üí∞ **Payment Methods:**\n\nüá≤üá≤ **Myanmar:**\n‚Ä¢ KBZ Pay\n‚Ä¢ Wave Pay\n‚Ä¢ AYA Pay\n‚Ä¢ UAB Pay\n\n"
               f"üåç **Global:**\n‚Ä¢ Binance\n‚Ä¢ Bybit\n‚Ä¢ Any Crypto (USDT)")
        bot.reply_to(message, msg, parse_mode="Markdown")
        
    elif text == 'üõí Buy Number':
        show_services(user_id, 0)

# ---------------- SERVICE MENU (CACHED) ----------------

def show_services(chat_id, page=0, msg_id=None):
    markup = types.InlineKeyboardMarkup(row_width=2)
    if page == 0:
        buttons = [types.InlineKeyboardButton(f"üì± {s.capitalize()}", callback_data=f"srv|{s}") for s in POPULAR_SERVICES]
        markup.add(*buttons)
        markup.add(types.InlineKeyboardButton("See All Services ‚§µÔ∏è", callback_data="page|1"))
        text = "üî• **Popular Services:**"
    else:
        # Use Cached Prices API (guest/products/any/any is heavy, ideally cache this too)
        # For simplicity, we fetch but rely on previous logic
        try:
            resp = requests.get(f"{BASE_URL}/guest/products/any/any", headers=HEADERS).json()
            services = [k for k, v in resp.items() if v.get('Qty', 0) > 0]
            services.sort()
            PER_PAGE = 30
            total_pages = (len(services) + PER_PAGE - 1) // PER_PAGE
            start = (page - 1) * PER_PAGE
            end = start + PER_PAGE
            current_batch = services[start:end]
            buttons = [types.InlineKeyboardButton(s, callback_data=f"srv|{s}") for s in current_batch]
            markup.add(*buttons)
            nav = []
            if page > 1: nav.append(types.InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=f"page|{page-1}"))
            if end < len(services): nav.append(types.InlineKeyboardButton("Next ‚û°Ô∏è", callback_data=f"page|{page+1}"))
            markup.add(*nav)
            markup.add(types.InlineKeyboardButton("‚¨ÖÔ∏è Back to Popular", callback_data="page|0"))
            text = f"üåê **All Services** (Page {page}/{total_pages}):"
        except: text = "Error fetching services."
    if msg_id: bot.edit_message_text(text, chat_id, msg_id, reply_markup=markup, parse_mode="Markdown")
    else: bot.send_message(chat_id, text, reply_markup=markup, parse_mode="Markdown")

# ---------------- COUNTRY MENU (CACHED) ----------------

def show_countries(chat_id, service, page=0, msg_id=None):
    bot.send_chat_action(chat_id, 'typing')
    try:
        # USE CACHE HERE
        resp = get_cached_prices(service) # Cached function
        data_source = resp.get(service, {}) if service in resp else resp
        
        countries = []
        for c_name, ops in data_source.items():
            if not isinstance(ops, dict): continue
            min_price_rub = float('inf')
            total_stock = 0
            for op, det in ops.items():
                if det['count'] > 0:
                    total_stock += det['count']
                    if det['cost'] < min_price_rub: min_price_rub = det['cost']
            if total_stock > 0:
                display_price = calculate_display_price(min_price_rub, chat_id)
                countries.append({'n': c_name, 'p': display_price, 's': total_stock})
        
        countries.sort(key=lambda x: x['p'])
        if not countries:
            bot.send_message(chat_id, "‚ùå No stock available (Wait for refresh).")
            return

        PER_PAGE = 20
        total_pages = (len(countries) + PER_PAGE - 1) // PER_PAGE
        if page < 0: page = 0
        if page >= total_pages: page = total_pages - 1
        start = page * PER_PAGE
        end = start + PER_PAGE
        current_batch = countries[start:end]

        markup = types.InlineKeyboardMarkup(row_width=1)
        for c in current_batch:
            flag = get_flag(c['n'])
            btn_txt = f"{flag} {c['n'].upper()} - from {c['p']} Ks ({c['s']})"
            markup.add(types.InlineKeyboardButton(btn_txt, callback_data=f"op|{c['n']}|{service}"))
        
        nav_btns = []
        if page > 0: nav_btns.append(types.InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data=f"cnt_pg|{service}|{page-1}"))
        if end < len(countries): nav_btns.append(types.InlineKeyboardButton("Next ‚û°Ô∏è", callback_data=f"cnt_pg|{service}|{page+1}"))
        markup.add(*nav_btns)
        markup.add(types.InlineKeyboardButton("‚¨ÖÔ∏è Back to Services", callback_data="page|0"))
        
        text = f"üåç **{service.upper()}** - Select Country (Page {page+1}/{total_pages}):"
        if msg_id: bot.edit_message_text(text, chat_id, msg_id, reply_markup=markup, parse_mode="Markdown")
        else: bot.send_message(chat_id, text, reply_markup=markup, parse_mode="Markdown")
    except Exception as e:
        logger.error(f"Error loading countries: {e}")
        bot.send_message(chat_id, "Error loading countries.")

# ---------------- OPERATOR MENU (CACHED) ----------------

def show_operators(chat_id, country, service, msg_id):
    try:
        # USE CACHE HERE
        resp = get_cached_prices(service)
        data_source = resp.get(service, {}).get(country, {})
        markup = types.InlineKeyboardMarkup(row_width=1)
        valid_ops = []
        for op, det i